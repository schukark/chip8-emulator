rd_("Aeregister index for VX000000000000000000000000000Aeregister index for VY00000000000CiVF register is used a lot here, so it is a predefined \xe2\x80\xa6CbHelper to get the VX register, reduced boilerplateAmThe main emulator applicationAoStore register and stack state\\AhChip8 cpu implementationiChip8 cpuAbCreate a new Chip8CfCreate a ram filled with digit sprites (0x000 - 0x1FF)A`Create a new CPUAgCreate an empty displayAcCreate a new keypadAi1NNN, jump to address NNNAjCXNN, VX = rand() &amp; NNAbANNN, set I to NNNBhSkip the next instruction, moves PC by 4BhWaiting on something, no need to move PCoBytes in memoryAoReturns the argument unchanged.0000000000000000000BaCalls <code>U::from(self)</code>.0000000000000000000BoLoad bytes into ram starting from given addressBbRun one fetch-decode-execute cycleAcFull Chip-8 machineBhDecay factor for the phosphor persitenceBh5XY0, if VX == VY, skip next instructionCkNewtype struct for register number, they are 4-bit in chip8n8XY1, VX |= VYnChip8 instanceA`Clear the screeneStackAiGet current display stateBhKeypad state on - pressed off - releasedCnNewtypes to make the operations with nibbles and registers \xe2\x80\xa6Acvalue to compare to0ovalue to assign0Adconstant to and withAb8XY2, VX &amp;= VYBkLast instruction jumped, no need to move PCA`Hex keypad (0-F)Ad8XYE, VX &lt;&lt;= 1A`Chip8 ram structBh9XY0, if VX != VY, skip next instructionAd8XY6, VX &gt;&gt;= 1Ao00EE, returns from the functionAjFX33, store BCD of VX to In8XY3, VX ^= VYmsprite heightBkMap the real input to hex keyboard of chip8AkChip8 keypad implementationlChip8 keypadDdMacros to simplify constructing decoded <code>Instruction</code> \xe2\x80\xa6AkChip8 memory implementationlChip8 memoryBh2D array of pixels true = on false = offBcPixels struct to draw on the windownGet randomnessBeModule that contains the window logicAfApplication\xe2\x80\x99s windowCfNewtype struct for addresses, they are 12-bit in chip8AnPC should advance to next wordAg64x32 monochrome screenBh3XNN, if VX == NN, skip next instructionAiAddress of the subroutineAbaddress to jump toAhsubroutine start addressAcaddress to set I to2AhGet address register (I)A`Address registerCfDecoder module containing implementations of chip8 \xe2\x80\xa6AlChip8 display implementationmChip8 displayAfExecute an instructionCdGeneral purpose registers, V0 through VF, 8 bit eachmChip8 machineC`Constructs an instruction with an address field.CgConstructs an instruction with a single register field.CcConstructs an instruction with two register fields.CmConstructs an instruction with two register fields and an \xe2\x80\xa6BiRuns the main application of the emulatoriCpu errorAkEnum of possible CPU errorsBh4XNN, if VX != NN, skip next instructionmSetup loggingAb8XY0, set VX to VYCkKeys are 0-F (inclusive), so if keys &gt;= 17 are being \xe2\x80\xa6AiFetch a byte from addressB`Fetch a 2-byte word from addressBkPop an address from the stack, returning itmWindow\xe2\x80\x99s IDBoEnum of all possible errors with chip8 instanceBoDXYN, draw sprite at VX, VY with height being NChEnum of program counter statuses after command executionAnBNNN, jump to address NNN + V0CeAccess of memory beyond 12 bit of addresses availableBdStack is empty, but pop was executedC`Flag that shows if any redraw is actually neededChCreate an application struct from a ready chip8 instanceAnQuery whether a key is pressednPlay the soundjAudio sinkCePush an addres onto stack, updating stack pointer \xe2\x80\xa6Ab6XNN, set VX to NNAjInstruction decoding errorBcEnum for all possible decode errorsBbAll the opcodes for chip8 emulatorlKeypad errorBcEnum for all possible keypad errorslMemory errorCeEnum with variants encoding all memory-related errorsBoReturns the first key that is pressed right nowAeGet delay timer valuekDelay timerBdDraw the sprite starting at (vx, vy)BoComplete list of opcodes for the chip8 emulatorBeLast time the timers were ticked downCnConstructs an instruction with a register and an immediate \xe2\x80\xa6AgPause the current soundBdSet a new address register value (I)AeGet sound timer valuekSound timerAnTick timers by one if possibleBcTick timers down by one if possiblen8XY4, VX += VYAh00E0, clears the displaymDisplay errorBdEnum for all possible display errorsCbProgram counter can\xe2\x80\x99t be bigger than 2^12 = 4096CiNewtype struct for sprite height, they are 4-bit in chip8CjThe height of chip8 display is 32, so no sprite can be \xe2\x80\xa6n8XY5, VX -= VYCmRedraw the display depending on the current chip8 display \xe2\x80\xa6CiLoad the program for execution, starting at address 0x200CgLoad the program from path and return a ready chip8 \xe2\x80\xa6CfFX0A, wait until any key is pressed and store it to VXBePredefined sprites for all hex digitsCcFX55, dump register V0..=VX in memory starting at IBaFX07, set VX to delay timer valueCeFX65, load register V0..=VX from memory starting at IAkFX15, set delay timer to VXAkFX18, set sound timer to VXAiFX29, I = sprite_addr[VX]CiCreates a value of type skipping the sanitization and \xe2\x80\xa6BiRandom engine for reproducible randomnessAaRun one cpu cycleBdForward the keypresses to the keypadChSets the new key state (pressed = true/released = false)mStack pointerAgStream handle for audion7XNN, VX += NNBd2NNN, call subroutine at address NNNCkEX9E, skip next instruction if key pressed matches with \xe2\x80\xa6CkThe time interval for 60hz (timers for chip8 operate on \xe2\x80\xa6AfChip8 emulator in rustB`Last time the cpu cycle happenedAo0NNN, call machine code routineChThere are exactly 16 sprites (0..=F), accesing other \xe2\x80\xa6CnEXA1, skip next instruction if key pressed doesn\xe2\x80\x99t match \xe2\x80\xa6BhIncrement address register by given stepAcGet program counteroProgram counteroSet delay timeroSet sound timermFX1E, I += VXCfAddresses before 0x200 are reserved and can\xe2\x80\x99t be \xe2\x80\xa6CaGet a snapshot of current display state to renderBcCheck if the sound should be playedBjAddress can\xe2\x80\x99t be bigger than 2^12 = 4096CkThe command\xe2\x80\x99s bytes don\xe2\x80\x99t correspond to any correct \xe2\x80\xa6AnStack is limited to 16 entriesBnHash of the last frame to consider rerenderingCiThe time interval for 500hz (simulate chip8 cpu at 500hz)Ab8XY7, VX = VY - VXBiFetch sprite address from reserved memoryAcSet program counterCjDetermine if the current display is different from the \xe2\x80\xa6BlTick the cpu timers and play sound if neededCeUnsupported instruction called (assembly subroutines)AgAdvance program counter")